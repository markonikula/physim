<!DOCTYPE html>
<html>
    <head>
        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@v0.156.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@v0.156.0/examples/jsm/"
                }
            }
        </script>
        <script type="module" src="js/main.js"></script>
    </head>
    <body style="margin: 0">
        <script id="vertexShader" type="x-shader/x-vertex">
            uniform float time;
            uniform vec2 resolution;
            varying vec4 posInCameraCoordinates;

            void main()	{
                //vec4 noise = (vec4(noise3((modelMatrix * instanceMatrix * vec4(position, 1.0)).xyz), 1.0) * 0.00005);
                vec4 cameraPos = viewMatrix * modelMatrix * instanceMatrix * vec4(position, 1.0);
                vec4 pos = projectionMatrix * cameraPos;
                gl_Position = pos;
                posInCameraCoordinates = cameraPos;
            }
        </script>

        <script id="fragmentShader" type="x-shader/x-fragment">
            uniform float time;
            uniform vec2 resolution;
            varying vec3 Normal;
            varying vec4 posInCameraCoordinates;
            void main()	{
                // Store 0.5 as W coordinate to allow checking if data exists in later phases
                gl_FragColor = vec4(vec3(posInCameraCoordinates), 0.5);
            }
        </script>

        <script id="vertexShader_screen" type="x-shader/x-vertex">
			varying vec2 uvPos;
			void main() {
				uvPos = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
		</script>

		<script id="fragmentShader_screen" type="x-shader/x-fragment">
			varying vec2 uvPos;
			uniform sampler2D buffer;
            uniform samplerCube background;
            uniform mat4 cameraMatrix;
            uniform mat4 worldMatrix;
            uniform vec3 realCameraPosition;

            float rand(float n){return (sin(n) * 43758.5453123);}

            float rand(vec2 n) {
                return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
            }

            float noise(float p){
	            float fl = floor(p);
                float fc = fract(p);
	            return mix(rand(fl), rand(fl + 1.0), fc);
            }

            float noise(vec2 n) {
	            const vec2 d = vec2(0.0, 1.0);
                vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));
	            return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);
            }

            vec3 noise3(vec3 n) {
                return vec3(noise(n.x), noise(n.y), noise(n.z)) - 0.5;
            }

			void main() {
                //vec4 tmpPos = vec4((uvPos.x - 0.5) * 2.0, (uvPos.y - 0.5) * 2.0, 0.0, -1.0);
                //vec4 worldPos = worldMatrix * (cameraMatrix * tmpPos);

                vec4 clipPos = vec4(uvPos, 1.0, 1.0);
                // inverse projection by clip position
                vec4 viewPos = cameraMatrix * clipPos;
                // perspective division
                viewPos /= viewPos.w;
                vec3 worldPos = (worldMatrix * viewPos).xyz;

                vec4 bgColor = textureCube(background, worldPos);

                vec4 srcFull = texture2D(buffer, uvPos);
                if (srcFull.w != 0.5) {
                    gl_FragColor = bgColor;
                    return;
                    //discard;
                }
                vec3 src = vec3(srcFull);

                if (uvPos.x <= 0.01 || uvPos.y <= 0.01) {
                    //discard;
                }

                vec4 srcXFull = texture2D(buffer, vec2(uvPos.x - 0.002, uvPos.y));
                vec4 srcYFull = texture2D(buffer, vec2(uvPos.x, uvPos.y - 0.002));
                if (srcXFull.w != 0.5 || srcYFull.w != 0.5) {
                    //discard;
                }

                vec3 srcX = vec3(srcXFull);
                vec3 srcY = vec3(srcYFull);
                vec3 tangentX = srcX - src;
                vec3 tangentY = srcY - src;
                vec3 normal = normalize(cross(tangentX, tangentY));
                normal = normalize(normal + (noise3(normal) * 100.0));

                // From http://kylehalladay.com/blog/tutorial/2014/02/18/Fresnel-Shaders-From-The-Ground-Up.html
                float scale = 2.5;
                float power = 1.5;
                float R = max(0.0, min(1.0, scale * pow(1.0 + dot(normalize(src), normal), power)));
                //vec3 fresnelColor = vec3(1.0, 1.0, 1.0);
                vec3 srcWorldPos = (worldMatrix * vec4(src.xyz, 1.0)).xyz;
                vec3 srcToCamera = realCameraPosition - srcWorldPos;
                vec3 reflection = reflect(srcToCamera, normal);
                vec3 waterBgColor = textureCube(background, -srcToCamera).xyz;
                vec3 fresnelColor = textureCube(background, reflection).xyz;
                vec3 baseColor = vec3(0.1, 0.1, 0.6);
                vec3 color = mix(baseColor, waterBgColor, 0.5);
                gl_FragColor = vec4(mix(color, fresnelColor, R), 1.0);

                /*
                // From https://learnopengl.com/Advanced-Lighting/Advanced-Lighting
                vec3 lightPos = vec3(5000.0, 5000.0, 500.0);
                vec3 viewPos = vec3(0.0, 0.0, -100.0);  // XXX
                vec3 lightDir   = normalize(lightPos - src);
                vec3 viewDir    = normalize(viewPos - src);
                vec3 halfwayDir = normalize(lightDir + viewDir);
                float shininess = 0.9;
                float spec = pow(max(dot(normal, halfwayDir), 0.0), shininess);

                //float spec = max(dot(normal, lightDir), 0.0);
                vec3 lightColor = vec3(0.2, 0.3, 1.0);
                vec3 specular = ((lightColor * spec) * 0.5);
                gl_FragColor = vec4(specular, 1.0);

                //vec3 color = (normalize(normal) * 0.5) + 0.5;
                //gl_FragColor = vec4(color, 1.0);
                */

				#include <colorspace_fragment>
			}
		</script>

		<script id="fragmentShader_zBlur" type="x-shader/x-fragment">
            // Adapted from https://stackoverflow.com/questions/64837705/opengl-blurring
            varying vec2 uvPos;               // screen position [<0,+1>, <0,+1>]
            uniform sampler2D buffer;       // texture to blur
            uniform float xs, ys;           // texture resolution
            uniform float r;                // blur radius

            void main() {
                float x, y, xx, yy, rr = r * r, dx = 1.0 / xs, dy = 1.0 / ys, w, w0;
                w0 = 0.3780 / pow(r, 1.975);
                vec2 p;
                float sum = 0.0;
                float count = 0.0;
                for (x = -r, p.x = uvPos.x + (x * dx); x<=r; x++, p.x += dx) {
                    xx = x * x;
                    for (y = -r, p.y = uvPos.y + (y * dy); y<=r; y++, p.y += dy){
                        yy = y * y;
                        if (xx + yy <= rr && p.x >= 0.0 && p.y >= 0.0 && p.x <= 1.0 && p.y <= 1.0) {
                            w = w0 * exp((-xx-yy) / (2.0 * rr));
                            float value = texture2D(buffer, p).z; // * w;
                            if (!isnan(value)) {
                                sum += value;
                                count += 1.0;
                            }
                        }
                    }
                }
                if (count > 0.0) {
                    sum = sum / count;
                }

                vec4 orig = texture2D(buffer, uvPos);
                //sum += orig.x;
                //gl_FragColor = vec4(orig.x, sum, sum, 1.0);
                //gl_FragColor = vec4(isnan(sum) ? 0.2 : 0.8, 0.0, 0.0, 1.0);
                //gl_FragColor = vec4(sum < 0.1 ? 0.2 : 0.8, 0.0, orig.z, 1.0);
                //gl_FragColor = orig;
                gl_FragColor = vec4(orig.x, orig.y, sum, orig.w);

                //gl_FragColor = vec4(uvPos.x, 0.0, 0.0, 1.0);
                //gl_FragColor = vec4(0.1, 0.9, 0.5, 1.0);

				#include <colorspace_fragment>
            }
        </script>
    </body>
</html>
